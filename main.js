/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// main.ts
__export(exports, {
  default: () => AITaggerPlugin
});
var import_obsidian5 = __toModule(require("obsidian"));

// settings.ts
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  apiKey: "",
  apiEndpoint: "https://api.openai.com/v1/chat/completions",
  tagCount: 5,
  apiModel: "gpt-3.5-turbo",
  promptTemplate: "Please generate tags for the following note content, with a maximum of {{tagCount}} tags. The tags should concisely summarize the main topics of the note. Please automatically determine the appropriate number of tags based on the content - the richer the content, the more diverse the tags. Return only the tags, each starting with # and separated by spaces. Note content: {{content}}",
  clusterCount: 10,
  embeddingApiKey: "",
  embeddingApiEndpoint: "https://api.openai.com/v1/embeddings",
  embeddingModel: "text-embedding-ada-002",
  lastClusterDate: 0
};
var AITaggerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("tagger-settings");
    const taggerSection = containerEl.createEl("div", { cls: "settings-section tagger-section" });
    taggerSection.createEl("h2", { text: "AI Tag Generator Settings" });
    new import_obsidian.Setting(taggerSection).setName("API Key").setDesc("Enter your API key (e.g., DeepSeek API key)").addText((text) => text.setPlaceholder("Enter API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }).inputEl.addClass("api-key-input"));
    new import_obsidian.Setting(taggerSection).setName("API Endpoint").setDesc("The endpoint URL for the large language model API (e.g., https://api.deepseek.com/v1/chat/completions, please check documentation)").addText((text) => text.setPlaceholder("https://api.deepseek.com/v1/chat/completions").setValue(this.plugin.settings.apiEndpoint).onChange(async (value) => {
      this.plugin.settings.apiEndpoint = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(taggerSection).setName("API Model").setDesc("The LLM model to use (e.g., deepseek-chat, please fill in correctly)").addText((text) => text.setPlaceholder("deepseek-chat").setValue(this.plugin.settings.apiModel).onChange(async (value) => {
      this.plugin.settings.apiModel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(taggerSection).setName("Maximum Tag Count").setDesc("Maximum number of tags to generate for each note (1-20). Fewer tags may be generated based on content.").addSlider((slider) => slider.setLimits(1, 20, 1).setValue(this.plugin.settings.tagCount).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.tagCount = value;
      await this.plugin.saveSettings();
    }).sliderEl.addClass("tag-count-slider"));
    new import_obsidian.Setting(taggerSection).setName("Prompt").setDesc("The prompt sent to the AI").addTextArea((text) => text.setPlaceholder("Enter prompt").setValue(this.plugin.settings.promptTemplate).onChange(async (value) => {
      this.plugin.settings.promptTemplate = value;
      await this.plugin.saveSettings();
    }).inputEl.addClass("prompt-textarea"));
    new import_obsidian.Setting(taggerSection).addButton((button) => button.setButtonText("Tag All Notes").setCta().onClick(async () => {
      await this.plugin.tagAllNotes();
    }));
    const clusterSection = containerEl.createEl("div", { cls: "settings-section cluster-section" });
    clusterSection.createEl("h2", { text: "Topic Clustering Settings" });
    new import_obsidian.Setting(clusterSection).setName("Embedding API Key").setDesc("API key for generating text vectors").addText((text) => text.setPlaceholder("Enter Embedding API key, leave empty to use the API key above").setValue(this.plugin.settings.embeddingApiKey).onChange(async (value) => {
      this.plugin.settings.embeddingApiKey = value;
      await this.plugin.saveSettings();
    }).inputEl.addClass("api-key-input"));
    new import_obsidian.Setting(clusterSection).setName("Embedding API Endpoint").setDesc("API endpoint URL for generating text vectors").addText((text) => text.setPlaceholder("https://api.openai.com/v1/embeddings").setValue(this.plugin.settings.embeddingApiEndpoint).onChange(async (value) => {
      this.plugin.settings.embeddingApiEndpoint = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(clusterSection).setName("Embedding Model").setDesc("Model for generating text vectors").addText((text) => text.setPlaceholder("text-embedding-ada-002").setValue(this.plugin.settings.embeddingModel).onChange(async (value) => {
      this.plugin.settings.embeddingModel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(clusterSection).setName("Cluster Count").setDesc("Number of topic clusters to divide notes into (2-20)").addSlider((slider) => slider.setLimits(2, 20, 1).setValue(this.plugin.settings.clusterCount).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.clusterCount = value;
      await this.plugin.saveSettings();
    }).sliderEl.addClass("cluster-count-slider"));
    new import_obsidian.Setting(clusterSection).addButton((button) => button.setButtonText("Analyze Note Topics").setCta().onClick(async () => {
      await this.plugin.analyzeAllNotes();
    }));
    const infoDiv = clusterSection.createEl("div", {
      cls: "cluster-info-message",
      text: "Since tag information is used to enhance clustering for better results, you need to complete tagging all notes before analyzing note topics"
    });
  }
};

// embedding-service.ts
var import_obsidian2 = __toModule(require("obsidian"));
var EmbeddingService = class {
  constructor(settings) {
    this.settings = settings;
  }
  async generateEmbedding(content) {
    try {
      const maxContentLength = 8e3;
      const truncatedContent = content.length > maxContentLength ? content.substring(0, maxContentLength) : content;
      console.log(`\u751F\u6210\u5D4C\u5165\u5411\u91CF\uFF0C\u5185\u5BB9\u957F\u5EA6: ${truncatedContent.length} \u5B57\u7B26`);
      const apiKey = this.settings.embeddingApiKey || this.settings.apiKey;
      if (!apiKey) {
        throw new Error("\u672A\u8BBE\u7F6EAPI\u5BC6\u94A5");
      }
      const apiEndpoint = this.settings.embeddingApiEndpoint || "https://api.openai.com/v1/embeddings";
      console.log(`\u4F7F\u7528API\u7AEF\u70B9: ${apiEndpoint}`);
      console.log(`\u4F7F\u7528\u5D4C\u5165\u6A21\u578B: ${this.settings.embeddingModel}`);
      const isCloseAI = apiEndpoint.includes("closeai-asia.com") || apiEndpoint.includes("closeai.com");
      console.log(`\u68C0\u6D4B\u5230API\u7C7B\u578B: ${isCloseAI ? "CloseAI" : "OpenAI"}`);
      let requestBody;
      if (isCloseAI) {
        requestBody = JSON.stringify({
          model: this.settings.embeddingModel,
          input: [truncatedContent],
          encoding_format: "float"
        });
      } else {
        requestBody = JSON.stringify({
          model: this.settings.embeddingModel,
          input: truncatedContent
        });
      }
      console.log(`\u53D1\u9001\u8BF7\u6C42\u4F53\u7ED3\u6784: ${JSON.stringify(JSON.parse(requestBody), null, 2).substring(0, 200)}...`);
      try {
        const response = await (0, import_obsidian2.requestUrl)({
          url: apiEndpoint,
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${apiKey}`
          },
          body: requestBody
        });
        console.log(`API\u54CD\u5E94\u72B6\u6001\u7801: ${response.status}`);
        if (response.status !== 200) {
          console.error(`\u5D4C\u5165API\u9519\u8BEF\u54CD\u5E94: ${JSON.stringify(response.json, null, 2)}`);
          throw new Error(`API\u9519\u8BEF: ${response.status}, \u4FE1\u606F: ${JSON.stringify(response.json)}`);
        }
        console.log(`API\u54CD\u5E94\u7ED3\u6784: ${JSON.stringify(Object.keys(response.json), null, 2)}`);
        let embedding;
        if (isCloseAI) {
          console.log(`\u5904\u7406CloseAI\u54CD\u5E94\u683C\u5F0F`);
          if (response.json.output && response.json.output.embeddings && response.json.output.embeddings.length > 0) {
            console.log(`\u4ECEresponse.json.output.embeddings\u83B7\u53D6embedding`);
            embedding = response.json.output.embeddings[0].embedding;
          } else if (response.json.data && response.json.data.length > 0) {
            console.log(`\u4ECEresponse.json.data\u83B7\u53D6embedding`);
            embedding = response.json.data[0].embedding;
          } else {
            console.error(`\u65E0\u6CD5\u89E3\u6790\u54CD\u5E94\u7ED3\u6784: ${JSON.stringify(response.json, null, 2)}`);
            throw new Error("\u65E0\u6CD5\u4ECE\u54CD\u5E94\u4E2D\u83B7\u53D6embedding");
          }
        } else {
          console.log(`\u5904\u7406OpenAI\u54CD\u5E94\u683C\u5F0F`);
          embedding = response.json.data[0].embedding;
        }
        if (!embedding || !Array.isArray(embedding)) {
          console.error(`\u83B7\u53D6\u5230\u7684embedding\u65E0\u6548: ${JSON.stringify(embedding)}`);
          throw new Error("\u83B7\u53D6\u7684embedding\u683C\u5F0F\u65E0\u6548");
        }
        console.log(`\u6210\u529F\u83B7\u53D6\u5D4C\u5165\u5411\u91CF\uFF0C\u7EF4\u5EA6: ${embedding.length}`);
        return embedding;
      } catch (requestError) {
        console.error(`\u8BF7\u6C42API\u51FA\u9519: ${requestError.message}`, requestError);
        console.error(`\u8BF7\u6C42URL: ${apiEndpoint}`);
        console.error(`\u8BF7\u6C42\u4F53: ${requestBody}`);
        throw new Error(`\u8BF7\u6C42\u5D4C\u5165API\u5931\u8D25: ${requestError.message}`);
      }
    } catch (error) {
      console.error("\u751F\u6210\u5D4C\u5165\u5411\u91CF\u65F6\u51FA\u9519:", error);
      throw error;
    }
  }
  calculateCosineSimilarity(vecA, vecB) {
    if (vecA.length !== vecB.length) {
      throw new Error("\u5411\u91CF\u7EF4\u5EA6\u4E0D\u5339\u914D");
    }
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < vecA.length; i++) {
      dotProduct += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }
    if (normA === 0 || normB === 0) {
      return 0;
    }
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }
};

// clustering-service.ts
var import_obsidian3 = __toModule(require("obsidian"));
var ClusteringService = class {
  constructor(embeddingService, settings) {
    this.embeddingService = embeddingService;
    this.settings = settings;
  }
  async clusterVectors(embeddings, k = 10) {
    console.log(`\u5F00\u59CB\u805A\u7C7B\u5206\u6790\uFF0C\u7B14\u8BB0\u6570\u91CF: ${embeddings.length}\uFF0C\u805A\u7C7B\u6570\u91CF: ${k}`);
    if (embeddings.length < k) {
      k = Math.max(2, Math.floor(embeddings.length / 2));
      console.log(`\u7B14\u8BB0\u6570\u91CF\u5C0F\u4E8E\u805A\u7C7B\u6570\u91CF\uFF0C\u8C03\u6574\u805A\u7C7B\u6570\u91CF\u4E3A: ${k}`);
    }
    let centroids = this.initializeCentroids(embeddings, k);
    const maxIterations = 30;
    let iterations = 0;
    let clusters = [];
    let prevClusters = [];
    while (iterations < maxIterations) {
      clusters = this.assignToClusters(embeddings, centroids);
      if (this.hasConverged(clusters, prevClusters)) {
        console.log(`\u805A\u7C7B\u5DF2\u6536\u655B\uFF0C\u8FED\u4EE3\u6B21\u6570: ${iterations}`);
        break;
      }
      centroids = this.updateCentroids(embeddings, clusters);
      prevClusters = JSON.parse(JSON.stringify(clusters));
      iterations++;
    }
    const nonEmptyClusters = clusters.filter((cluster) => cluster.length > 0);
    if (nonEmptyClusters.length < clusters.length) {
      console.log(`\u6709 ${clusters.length - nonEmptyClusters.length} \u4E2A\u7A7A\u805A\u7C7B\u88AB\u79FB\u9664`);
      clusters = nonEmptyClusters;
    }
    const clusterResults = await this.generateClusterResults(embeddings, clusters);
    console.log("\u805A\u7C7B\u5B8C\u6210:", clusterResults);
    return clusterResults;
  }
  initializeCentroids(embeddings, k) {
    const centroids = [];
    const dimension = embeddings[0].vector.length;
    const firstIndex = Math.floor(Math.random() * embeddings.length);
    centroids.push([...embeddings[firstIndex].vector]);
    for (let i = 1; i < k; i++) {
      const distances = embeddings.map((embedding) => {
        const minDistance = centroids.reduce((min, centroid) => {
          const distance = this.calculateDistance(embedding.vector, centroid);
          return Math.min(min, distance);
        }, Infinity);
        return minDistance;
      });
      const sum = distances.reduce((a, b) => a + b, 0);
      let rand = Math.random() * sum;
      let nextIndex = 0;
      while (rand > 0 && nextIndex < distances.length) {
        rand -= distances[nextIndex];
        nextIndex++;
      }
      nextIndex = Math.max(0, nextIndex - 1);
      centroids.push([...embeddings[nextIndex].vector]);
    }
    return centroids;
  }
  calculateDistance(vecA, vecB) {
    let sum = 0;
    for (let i = 0; i < vecA.length; i++) {
      const diff = vecA[i] - vecB[i];
      sum += diff * diff;
    }
    return Math.sqrt(sum);
  }
  assignToClusters(embeddings, centroids) {
    const clusters = Array(centroids.length).fill(0).map(() => []);
    embeddings.forEach((embedding, index) => {
      let minDistance = Infinity;
      let clusterIndex = 0;
      centroids.forEach((centroid, i) => {
        const distance = this.calculateDistance(embedding.vector, centroid);
        if (distance < minDistance) {
          minDistance = distance;
          clusterIndex = i;
        }
      });
      clusters[clusterIndex].push(index);
    });
    return clusters;
  }
  hasConverged(clusters, prevClusters) {
    if (!prevClusters.length)
      return false;
    for (let i = 0; i < clusters.length; i++) {
      if (!prevClusters[i])
        return false;
      if (clusters[i].length !== prevClusters[i].length)
        return false;
      const set = new Set(clusters[i]);
      for (const item of prevClusters[i]) {
        if (!set.has(item))
          return false;
      }
    }
    return true;
  }
  updateCentroids(embeddings, clusters) {
    return clusters.map((cluster) => {
      if (cluster.length === 0) {
        const randomIndex = Math.floor(Math.random() * embeddings.length);
        return [...embeddings[randomIndex].vector];
      }
      const dimension = embeddings[0].vector.length;
      const centroid = new Array(dimension).fill(0);
      cluster.forEach((index) => {
        const vector = embeddings[index].vector;
        for (let i = 0; i < dimension; i++) {
          centroid[i] += vector[i];
        }
      });
      for (let i = 0; i < dimension; i++) {
        centroid[i] /= cluster.length;
      }
      return centroid;
    });
  }
  async generateClusterResults(embeddings, clusters) {
    const results = [];
    for (let i = 0; i < clusters.length; i++) {
      const cluster = clusters[i];
      if (cluster.length === 0)
        continue;
      const clusterNotes = cluster.map((index) => {
        return {
          title: embeddings[index].title,
          path: embeddings[index].filePath,
          tags: embeddings[index].tags
        };
      });
      const allTags = [];
      clusterNotes.forEach((note) => {
        if (note.tags && note.tags.length > 0) {
          allTags.push(...note.tags);
        }
      });
      const tagFrequency = {};
      allTags.forEach((tag) => {
        tag = tag.replace(/^#/, "");
        tagFrequency[tag] = (tagFrequency[tag] || 0) + 1;
      });
      const keywords = Object.entries(tagFrequency).sort((a, b) => b[1] - a[1]).slice(0, 5).map((entry) => entry[0]);
      if (keywords.length < 3) {
        const titleWords = new Set();
        clusterNotes.forEach((note) => {
          const words = note.title.split(/[,\s，。：:、.]+/).filter((word) => word.length > 1).map((word) => word.toLowerCase());
          words.forEach((word) => titleWords.add(word));
        });
        [...titleWords].slice(0, 5 - keywords.length).forEach((word) => {
          if (!keywords.includes(word)) {
            keywords.push(word);
          }
        });
      }
      const label = keywords.slice(0, 3).join(", ");
      results.push({
        id: i,
        label,
        noteCount: cluster.length,
        noteIds: cluster,
        keywords
      });
    }
    for (let i = 0; i < results.length; i++) {
      const result = results[i];
      if (result.keywords.length < 3 || result.label.length < 5) {
        try {
          const titles = result.noteIds.map((id) => embeddings[id].title).join("\n");
          const betterLabel = await this.generateClusterLabel(titles, result.keywords);
          if (betterLabel) {
            result.label = betterLabel;
            console.log(`\u4E3A\u805A\u7C7B ${i} \u751F\u6210\u66F4\u597D\u7684\u6807\u7B7E: ${betterLabel}`);
          }
        } catch (error) {
          console.error(`\u4E3A\u805A\u7C7B ${i} \u751F\u6210\u6807\u7B7E\u65F6\u51FA\u9519:`, error);
        }
      }
    }
    return results;
  }
  async generateClusterLabel(titles, existingKeywords) {
    var _a, _b;
    try {
      const prompt = `\u4EE5\u4E0B\u662F\u4E00\u7EC4\u76F8\u5173\u7B14\u8BB0\u7684\u6807\u9898:
${titles}

\u5DF2\u77E5\u7684\u5173\u952E\u8BCD: ${existingKeywords.join(", ")}

\u8BF7\u4E3A\u8FD9\u7EC4\u7B14\u8BB0\u751F\u6210\u4E00\u4E2A\u7B80\u6D01\u7684\u4E3B\u9898\u6807\u7B7E\uFF0C\u4F7F\u75283\u4E2A\u5173\u952E\u8BCD\uFF0C\u7528\u5355\u4E2A\u9017\u53F7\u52A0\u7A7A\u683C\u5206\u9694\uFF08\u4F8B\u5982"\u5173\u952E\u8BCD1, \u5173\u952E\u8BCD2, \u5173\u952E\u8BCD3"\uFF09\u3002\u53EA\u8FD4\u56DE\u6807\u7B7E\uFF0C\u4E0D\u8981\u6709\u5176\u4ED6\u5185\u5BB9\u3002`;
      const apiKey = this.settings.apiKey;
      if (!apiKey) {
        throw new Error("\u672A\u8BBE\u7F6EAPI\u5BC6\u94A5");
      }
      const response = await (0, import_obsidian3.requestUrl)({
        url: this.settings.apiEndpoint,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: this.settings.apiModel,
          messages: [
            { role: "system", content: "\u4F60\u662F\u4E00\u4E2A\u4E13\u4E1A\u7684\u6587\u6863\u5206\u6790\u52A9\u624B\uFF0C\u64C5\u957F\u4E3A\u6587\u6863\u7EC4\u751F\u6210\u4E3B\u9898\u6807\u7B7E\u3002" },
            { role: "user", content: prompt }
          ],
          temperature: 0.3,
          max_tokens: 50
        })
      });
      if (response.status === 200) {
        const content = ((_b = (_a = response.json.choices[0]) == null ? void 0 : _a.message) == null ? void 0 : _b.content) || "";
        const cleanLabel = content.replace(/^["'\s]|["'\s]$/g, "").trim().replace(/,,+/g, ",");
        return cleanLabel.length > 0 ? cleanLabel : void 0;
      }
      return void 0;
    } catch (error) {
      console.error("\u751F\u6210\u805A\u7C7B\u6807\u7B7E\u65F6\u51FA\u9519:", error);
      return void 0;
    }
  }
};

// topic-browser-view.ts
var import_obsidian4 = __toModule(require("obsidian"));
var TOPIC_BROWSER_VIEW_TYPE = "topic-browser-view";
var TopicBrowserView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.clusters = [];
    this.isLoading = false;
    this.plugin = plugin;
    this.contentEl = null;
    this.loadingEl = null;
  }
  getViewType() {
    return TOPIC_BROWSER_VIEW_TYPE;
  }
  getDisplayText() {
    return "Note Topic Browser";
  }
  getIcon() {
    return "stacked-levels";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("topic-browser-container");
    const headerEl = container.createDiv("topic-browser-header");
    const searchContainer = headerEl.createDiv("topic-browser-search-container");
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search topics or notes...",
      cls: "topic-browser-search"
    });
    searchInput.addEventListener("input", () => {
      this.filterTopics(searchInput.value);
    });
    const controlsPanel = headerEl.createDiv("topic-browser-controls");
    const clusterCountDiv = controlsPanel.createDiv("cluster-count-control");
    clusterCountDiv.createSpan({
      text: "Cluster count:",
      cls: "cluster-count-label"
    });
    const clusterCountInput = clusterCountDiv.createEl("input", {
      type: "number",
      value: String(this.plugin.settings.clusterCount),
      min: "2",
      max: "20",
      cls: "cluster-count-input"
    });
    const applyButton = clusterCountDiv.createEl("button", {
      text: "Apply",
      cls: "ai-tagger-button"
    });
    const refreshButton = controlsPanel.createEl("button", {
      text: "Reanalyze",
      cls: "ai-tagger-button primary"
    });
    applyButton.addEventListener("click", async () => {
      const newCount = parseInt(clusterCountInput.value);
      if (newCount >= 2 && newCount <= 20) {
        this.plugin.settings.clusterCount = newCount;
        await this.plugin.saveSettings();
        this.setLoading(true);
        await this.plugin.analyzeAllNotes();
        this.setLoading(false);
      }
    });
    refreshButton.addEventListener("click", async () => {
      this.setLoading(true);
      await this.plugin.analyzeAllNotes();
      this.setLoading(false);
    });
    this.loadingEl = container.createDiv("loading-indicator");
    this.loadingEl.createDiv("loading-spinner");
    this.loadingEl.createDiv("loading-text").setText("Loading topic data...");
    this.loadingEl.style.display = "none";
    this.contentEl = container.createDiv("topic-browser-topics");
    this.setLoading(true);
    await this.plugin.loadClusterData();
    await this.loadClusters();
    this.setLoading(false);
  }
  setLoading(loading) {
    this.isLoading = loading;
    if (this.loadingEl) {
      this.loadingEl.style.display = loading ? "flex" : "none";
    }
    if (this.contentEl) {
      this.contentEl.style.opacity = loading ? "0.5" : "1";
      this.contentEl.style.pointerEvents = loading ? "none" : "auto";
    }
  }
  async loadClusters() {
    if (!this.contentEl)
      return;
    console.log("Loading cluster data to view...");
    const clusters = await this.plugin.getClusterResults();
    console.log(`Retrieved ${clusters ? clusters.length : 0} clusters`);
    if (clusters && clusters.length > 0) {
      this.clusters = clusters;
      console.log("Starting to render cluster data to view, cluster count:", clusters.length);
      this.renderClusters();
    } else {
      console.log("No cluster data found, showing empty state");
      this.renderEmptyState();
    }
  }
  renderEmptyState() {
    if (!this.contentEl)
      return;
    this.contentEl.empty();
    const noResults = this.contentEl.createDiv("no-results");
    noResults.createDiv("no-results-icon").setText("\u{1F4DD}");
    noResults.createDiv("no-results-text").setText("No topic analysis data yet");
    noResults.createDiv("no-results-subtext").setText('Click the "Reanalyze" button to start analyzing your note collection and discover thematic connections between notes.');
  }
  renderClusters() {
    if (!this.contentEl)
      return;
    this.contentEl.empty();
    if (this.clusters.length === 0) {
      this.renderEmptyState();
      return;
    }
    for (let i = 0; i < this.clusters.length; i++) {
      const cluster = this.clusters[i];
      const clusterDiv = this.contentEl.createDiv({ cls: "topic-cluster" });
      clusterDiv.setAttribute("data-index", i.toString());
      const headerDiv = clusterDiv.createDiv("topic-header");
      const titleEl = headerDiv.createDiv("topic-title");
      const cleanLabel = (cluster.label || `Topic ${i + 1}`).replace(/,,+/g, ",");
      titleEl.setText(cleanLabel);
      const badgeEl = headerDiv.createSpan("topic-badge");
      badgeEl.setText(`${cluster.noteIds.length}`);
      const contentDiv = clusterDiv.createDiv("topic-content");
      contentDiv.style.display = "none";
      if (cluster.keywords && cluster.keywords.length > 0) {
        const keywords = cluster.keywords.slice(0, 5);
        keywords.forEach((keyword) => {
          contentDiv.createSpan({
            cls: "topic-keyword",
            text: keyword
          });
        });
      }
      const notesContainer = clusterDiv.createDiv({ cls: "topic-notes" });
      headerDiv.addEventListener("click", async (e) => {
        const isExpanded = clusterDiv.hasClass("expanded");
        this.contentEl.querySelectorAll(".topic-cluster.expanded").forEach((el) => {
          if (el !== clusterDiv) {
            el.removeClass("expanded");
            const otherContentDiv = el.querySelector(".topic-content");
            if (otherContentDiv) {
              otherContentDiv.style.display = "none";
            }
          }
        });
        if (isExpanded) {
          clusterDiv.removeClass("expanded");
          contentDiv.style.display = "none";
        } else {
          clusterDiv.addClass("expanded");
          contentDiv.style.display = "flex";
          if (notesContainer.childElementCount === 0) {
            await this.renderNotesList(notesContainer, cluster);
          }
        }
      });
    }
  }
  filterTopics(query) {
    if (!query) {
      this.contentEl.querySelectorAll(".topic-cluster").forEach((el) => {
        el.style.display = "block";
      });
      return;
    }
    const lowerQuery = query.toLowerCase();
    this.contentEl.querySelectorAll(".topic-cluster").forEach((clusterEl) => {
      const titleEl = clusterEl.querySelector(".topic-title");
      const title = titleEl ? titleEl.textContent.toLowerCase() : "";
      if (title.includes(lowerQuery)) {
        clusterEl.style.display = "block";
        return;
      }
      const keywords = clusterEl.querySelectorAll(".topic-keyword");
      let hasMatchingKeyword = false;
      keywords.forEach((keyword) => {
        if (keyword.textContent.toLowerCase().includes(lowerQuery)) {
          hasMatchingKeyword = true;
        }
      });
      if (hasMatchingKeyword) {
        clusterEl.style.display = "block";
        return;
      }
      const noteLinks = clusterEl.querySelectorAll(".note-link");
      let hasMatchingNote = false;
      noteLinks.forEach((link) => {
        if (link.textContent.toLowerCase().includes(lowerQuery)) {
          hasMatchingNote = true;
        }
      });
      clusterEl.style.display = hasMatchingNote ? "block" : "none";
    });
  }
  async renderNotesList(container, cluster) {
    try {
      const notes = await this.plugin.getClusterNotes(cluster.id);
      if (notes.length === 0) {
        container.createDiv("no-notes-message").setText("No notes in this topic");
        return;
      }
      const notesList = container.createEl("ul", { cls: "notes-list" });
      notes.forEach((note, index) => {
        const noteItem = notesList.createEl("li", { cls: "note-item" });
        noteItem.style.setProperty("--item-index", index.toString());
        noteItem.createSpan("note-icon");
        const noteLink = noteItem.createEl("a", {
          cls: "note-link",
          href: note.path,
          text: note.title
        });
        noteLink.addEventListener("click", (event) => {
          event.preventDefault();
          event.stopPropagation();
          const targetFile = this.app.vault.getAbstractFileByPath(note.path);
          if (targetFile instanceof import_obsidian4.TFile) {
            this.app.workspace.getLeaf().openFile(targetFile);
          }
        });
        if (note.tags && note.tags.length > 0) {
          const tagsContainer = noteItem.createDiv("note-tags");
          note.tags.slice(0, 3).forEach((tag) => {
            tagsContainer.createSpan({
              cls: "note-tag",
              text: tag
            });
          });
          if (note.tags.length > 3) {
            tagsContainer.createSpan({
              cls: "note-tag",
              text: `+${note.tags.length - 3}`
            });
          }
        }
      });
    } catch (error) {
      container.createDiv("error-message").setText(`Failed to load notes: ${error.message}`);
      console.error("Failed to load notes:", error);
    }
  }
};

// main.ts
var ConfirmationModal = class extends import_obsidian5.Modal {
  constructor(app, title, message, onConfirm) {
    super(app);
    this.onConfirm = onConfirm;
    this.message = message;
    this.title = title;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.title });
    contentEl.createEl("p", { text: this.message });
    new import_obsidian5.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => {
      this.close();
    })).addButton((btn) => btn.setButtonText("Confirm").setCta().onClick(() => {
      this.close();
      this.onConfirm();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AITaggerPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.clusterData = {
      clusters: [],
      vectors: [],
      lastUpdated: 0
    };
  }
  async onload() {
    await this.loadSettings();
    this.embeddingService = new EmbeddingService(this.settings);
    this.clusteringService = new ClusteringService(this.embeddingService, this.settings);
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.setText("");
    this.addSettingTab(new AITaggerSettingTab(this.app, this));
    this.registerView(TOPIC_BROWSER_VIEW_TYPE, (leaf) => {
      this.topicBrowserView = new TopicBrowserView(leaf, this);
      return this.topicBrowserView;
    });
    this.addRibbonIcon("tag", "Tag All Notes", async () => {
      await this.tagAllNotes();
    });
    this.addRibbonIcon("stacked-levels", "Show Note Topic Browser", () => {
      this.activateTopicBrowserView();
    });
    this.addCommand({
      id: "tag-all-notes",
      name: "Tag All Notes",
      callback: async () => {
        await this.tagAllNotes();
      }
    });
    this.addCommand({
      id: "tag-current-note",
      name: "Tag Current Note",
      editorCallback: async (editor, view) => {
        await this.tagCurrentNote(editor, view);
      }
    });
    this.addCommand({
      id: "clear-current-note-tags",
      name: "Clear Current Note Tags",
      editorCallback: async (editor, view) => {
        await this.clearCurrentNoteTags(editor, view);
      }
    });
    this.addCommand({
      id: "clear-all-notes-tags",
      name: "Clear All Notes Tags",
      callback: async () => {
        await this.clearAllNotesTags();
      }
    });
    this.addCommand({
      id: "adjust-tag-count",
      name: "Adjust Tag Count",
      callback: () => {
        new TagCountAdjustModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "analyze-note-topics",
      name: "Analyze Note Topics",
      callback: async () => {
        await this.analyzeAllNotes();
      }
    });
    this.addCommand({
      id: "open-topic-browser",
      name: "Open Topic Browser",
      callback: () => {
        this.activateTopicBrowserView();
      }
    });
    await this.loadClusterData();
    this.addCommand({
      id: "generate-tags",
      name: "\u4E3A\u5F53\u524D\u7B14\u8BB0\u751F\u6210\u6807\u7B7E",
      editorCallback: async (editor, view) => {
        await this.tagCurrentNote(editor, view);
      }
    });
    this.addCommand({
      id: "run-topic-clustering",
      name: "Run Topic Clustering",
      callback: async () => {
        const modal = new ConfirmationModal(this.app, "Confirm Topic Clustering", "This will analyze all note content and perform cluster analysis, which may take some time. Continue?", async () => {
          await this.analyzeAllNotes();
        });
        modal.open();
      }
    });
    this.addCommand({
      id: "setup-closeai-compatibility",
      name: "Configure CloseAI Compatibility Mode",
      callback: async () => {
        this.settings.embeddingApiEndpoint = "https://api.closeai-asia.com/v1/embeddings";
        this.settings.embeddingModel = "text-embedding-ada-002";
        await this.saveSettings();
        this.embeddingService = new EmbeddingService(this.settings);
        new import_obsidian5.Notice("CloseAI compatibility mode configured, please run topic clustering analysis again");
      }
    });
  }
  onunload() {
    console.log("Unloading AI Tagger plugin");
    this.saveClusterData().then(() => {
      console.log("Cluster data saved before plugin unload");
    }).catch((error) => {
      console.error("Failed to save cluster data before plugin unload:", error);
    });
    this.app.workspace.detachLeavesOfType(TOPIC_BROWSER_VIEW_TYPE);
  }
  async loadSettings() {
    const data = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
    if (data && data.clusterData) {
      this.clusterData = data.clusterData;
      console.log("Loaded cluster data from settings:", this.clusterData.clusters.length);
    } else {
      this.clusterData = {
        clusters: [],
        vectors: [],
        lastUpdated: 0
      };
      console.log("Initialized empty cluster data structure");
    }
  }
  async saveSettings() {
    const data = Object.assign({}, this.settings);
    if (this.clusterData) {
      data.clusterData = this.clusterData;
      console.log("Saving cluster data to settings:", this.clusterData.clusters.length);
    }
    await this.saveData(data);
  }
  async activateTopicBrowserView() {
    await this.loadClusterData();
    const { workspace } = this.app;
    const existingLeaf = workspace.getLeavesOfType(TOPIC_BROWSER_VIEW_TYPE)[0];
    if (existingLeaf) {
      workspace.revealLeaf(existingLeaf);
      return;
    }
    const leaf = workspace.getRightLeaf(false);
    await leaf.setViewState({
      type: TOPIC_BROWSER_VIEW_TYPE,
      active: true
    });
    workspace.revealLeaf(leaf);
  }
  async loadClusterData() {
    try {
      if (!this.clusterData) {
        this.clusterData = {
          clusters: [],
          vectors: [],
          lastUpdated: 0
        };
        console.log("Created new cluster data structure");
      } else {
        console.log("Cluster data already exists, clusters:", this.clusterData.clusters.length);
      }
    } catch (error) {
      this.clusterData = {
        clusters: [],
        vectors: [],
        lastUpdated: 0
      };
      console.error("Error loading cluster data:", error);
    }
  }
  async saveClusterData() {
    try {
      if (!this.clusterData) {
        this.clusterData = {
          clusters: [],
          vectors: [],
          lastUpdated: Date.now()
        };
      }
      this.clusterData.lastUpdated = Date.now();
      this.settings.lastClusterDate = Date.now();
      await this.saveSettings();
      console.log("Cluster data saved to settings, clusters:", this.clusterData.clusters.length);
    } catch (error) {
      console.error("Failed to save cluster data:", error);
      new import_obsidian5.Notice("Failed to save cluster data, please try again");
    }
  }
  async analyzeAllNotes() {
    try {
      const embeddingApiKey = this.settings.embeddingApiKey || this.settings.apiKey;
      if (!embeddingApiKey) {
        new import_obsidian5.Notice("Please configure API key in settings first");
        return;
      }
      if (this.topicBrowserView) {
        this.topicBrowserView.setLoading(true);
      }
      new import_obsidian5.Notice("Starting to analyze notes, this may take some time...");
      this.statusBarItem.setText("Analyzing notes...");
      const files = this.app.vault.getMarkdownFiles();
      console.log(`Starting to analyze ${files.length} files`);
      if (files.length === 0) {
        new import_obsidian5.Notice("No Markdown notes found");
        this.statusBarItem.setText("");
        if (this.topicBrowserView) {
          this.topicBrowserView.setLoading(false);
        }
        return;
      }
      const embeddings = [];
      let processedCount = 0;
      const batchSize = 5;
      for (let i = 0; i < files.length; i += batchSize) {
        const batch = files.slice(i, i + batchSize);
        const batchResults = await Promise.all(batch.map(async (file, index) => {
          try {
            const fileContent = await this.app.vault.read(file);
            const tagMatch = fileContent.match(/^(#[^\s#]+\s*)+\n+/);
            const tags = tagMatch ? tagMatch[0].match(/#[^\s#]+/g) || [] : [];
            const maxContentLength = 5e3;
            let content = fileContent;
            if (tagMatch) {
              content = fileContent.replace(/^(#[^\s#]+\s*)+\n+/, "");
            }
            if (content.length > maxContentLength) {
              content = content.substring(0, maxContentLength);
            }
            const vector = await this.embeddingService.generateEmbedding(content);
            processedCount++;
            this.statusBarItem.setText(`Analyzing notes: ${processedCount}/${files.length}`);
            return {
              fileIndex: i + index,
              filePath: file.path,
              title: file.basename,
              vector,
              tags
            };
          } catch (error) {
            console.error(`Error processing file ${file.path}:`, error);
            new import_obsidian5.Notice(`Error processing note ${file.basename}: ${error.message || "Unknown error"}`);
            return null;
          }
        }));
        const validResults = batchResults.filter((result) => result !== null);
        embeddings.push(...validResults);
        if (validResults.length === 0) {
          console.error("All files in this batch failed");
          if (embeddings.length === 0 && i >= batchSize * 2) {
            throw new Error("Unable to generate any valid embeddings, please check API settings");
          }
        }
        if (i + batchSize < files.length) {
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
      }
      if (embeddings.length === 0) {
        throw new Error("Unable to generate any vectors, please check API settings and note content");
      }
      this.statusBarItem.setText("Clustering analysis...");
      const clusters = await this.clusteringService.clusterVectors(embeddings, this.settings.clusterCount);
      this.clusterData = {
        clusters,
        vectors: embeddings,
        lastUpdated: Date.now()
      };
      const dataStr = JSON.stringify(this.clusterData);
      console.log(`Cluster data size: ${(dataStr.length / 1024).toFixed(2)} KB`);
      if (dataStr.length > 1e6) {
        console.warn("Cluster data too large, optimizing...");
        this.clusterData.vectors = embeddings.map((vec) => ({
          fileIndex: vec.fileIndex,
          filePath: vec.filePath,
          title: vec.title,
          tags: vec.tags,
          vector: vec.vector.map((v) => Math.round(v * 100) / 100)
        }));
        const optimizedDataStr = JSON.stringify(this.clusterData);
        console.log(`Optimized data size: ${(optimizedDataStr.length / 1024).toFixed(2)} KB`);
      }
      await this.saveClusterData();
      this.settings.lastClusterDate = Date.now();
      await this.saveSettings();
      if (this.topicBrowserView) {
        this.topicBrowserView.loadClusters();
        this.topicBrowserView.setLoading(false);
      }
      this.statusBarItem.setText("");
      new import_obsidian5.Notice(`Note topic analysis completed, ${clusters.length} topics generated, processed ${embeddings.length} notes`);
    } catch (error) {
      console.error("Error analyzing notes:", error);
      this.statusBarItem.setText("");
      new import_obsidian5.Notice("Error analyzing notes: " + (error.message || "Unknown error") + ". Please check API settings.");
      if (this.topicBrowserView) {
        this.topicBrowserView.setLoading(false);
      }
    }
  }
  async getClusterResults() {
    if (!this.clusterData || !this.clusterData.clusters) {
      console.log("Cluster data does not exist, returning empty array");
      return [];
    }
    return this.clusterData.clusters;
  }
  async saveClusterResults(clusters) {
    this.clusterData.clusters = clusters;
    await this.saveClusterData();
  }
  async getClusterNotes(clusterId) {
    const cluster = this.clusterData.clusters.find((c) => c.id === clusterId);
    if (!cluster)
      return [];
    return cluster.noteIds.map((noteId) => {
      const vector = this.clusterData.vectors[noteId];
      return {
        title: vector.title,
        path: vector.filePath,
        tags: vector.tags
      };
    });
  }
  async generateTags(content) {
    var _a, _b, _c, _d, _e, _f;
    if (!this.settings.apiKey) {
      new import_obsidian5.Notice("Please configure API key first");
      return [];
    }
    try {
      const maxContentLength = 4e3;
      const truncatedContent = content.length > maxContentLength ? content.substring(0, maxContentLength) + "..." : content;
      console.log(`Note content length: ${truncatedContent.length} characters`);
      const isDeepSeekAPI = this.settings.apiEndpoint.includes("deepseek.com");
      let userPrompt = this.settings.promptTemplate;
      if (userPrompt.includes("{{content}}")) {
        userPrompt = userPrompt.replace("{{content}}", truncatedContent).replace("{{tagCount}}", this.settings.tagCount.toString());
      } else {
        userPrompt = userPrompt.replace("{{tagCount}}", this.settings.tagCount.toString()) + "\n\nNote content:\n\n" + truncatedContent;
        console.log("Prompt template does not contain {{content}} placeholder, automatically appended note content");
      }
      let systemPrompt = "You are a professional tag generation assistant, generating related tags based on content.";
      if (isDeepSeekAPI) {
        systemPrompt = "You are a professional tag generation assistant. Please carefully analyze the note content provided by the user and generate related tags according to the user's instructions. Each tag should start with #. The system automatically determines the appropriate number of tags based on the content, but does not exceed the user-specified maximum number.";
      }
      const requestData = {
        model: isDeepSeekAPI ? "deepseek-chat" : this.settings.apiModel,
        messages: [
          {
            role: "system",
            content: systemPrompt
          },
          {
            role: "user",
            content: userPrompt
          }
        ],
        temperature: 0.3,
        max_tokens: 150,
        stream: false
      };
      console.log(`Preparing to send request to ${this.settings.apiEndpoint}, model: ${requestData.model}`);
      console.log(`System prompt: ${systemPrompt}`);
      console.log(`User prompt: ${userPrompt.substring(0, 100)}...`);
      const response = await (0, import_obsidian5.requestUrl)({
        url: this.settings.apiEndpoint,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiKey}`
        },
        body: JSON.stringify(requestData)
      });
      console.log(`Received API response, status code: ${response.status}`);
      let tagsText = "";
      if (isDeepSeekAPI) {
        const responseData = response.json;
        console.log("DeepSeek API response:", JSON.stringify(responseData));
        tagsText = ((_c = (_b = (_a = responseData.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content) || responseData.output || "";
      } else {
        const responseData = response.json;
        console.log("API response:", JSON.stringify(responseData));
        tagsText = ((_f = (_e = (_d = responseData.choices) == null ? void 0 : _d[0]) == null ? void 0 : _e.message) == null ? void 0 : _f.content) || "";
      }
      console.log("Generated tag text:", tagsText);
      const tagMatches = tagsText.match(/#[^\s#]+/g) || [];
      const tags = tagMatches.slice(0, this.settings.tagCount);
      console.log("Final extracted tags:", tags);
      return tags;
    } catch (error) {
      console.error("Error generating tags:", error);
      let errorMessage = "Failed to generate tags: ";
      if (error.status) {
        errorMessage += `status code ${error.status} - `;
        console.error("API returned status code:", error.status);
      }
      if (error.message) {
        errorMessage += error.message;
        console.error("Error message:", error.message);
      } else if (error.json) {
        errorMessage += JSON.stringify(error.json);
        console.error("API error response:", error.json);
      } else {
        errorMessage += "Unknown error";
      }
      new import_obsidian5.Notice(errorMessage);
      return [];
    }
  }
  async tagCurrentNote(editor, view) {
    try {
      if (!view.file) {
        new import_obsidian5.Notice("No note opened");
        return;
      }
      new import_obsidian5.Notice("Generating tags for current note...");
      this.statusBarItem.setText("Generating tags...");
      const content = editor.getValue();
      console.log("Getting current note content, length:", content.length);
      const tags = await this.generateTags(content);
      console.log("Generated tags:", tags);
      if (tags && tags.length > 0) {
        try {
          console.log("Clearing old tags");
          await this.clearCurrentNoteTags(editor, view);
          const tagsText = tags.join(" ");
          const tagsLine = tagsText + "\n\n";
          console.log("Preparing to add tags:", tagsText);
          editor.replaceRange(tagsLine, { line: 0, ch: 0 });
          await new Promise((resolve) => setTimeout(resolve, 100));
          const newContent = editor.getValue();
          if (newContent.startsWith(tagsText)) {
            console.log("Tags added successfully, verification passed");
            this.statusBarItem.setText("");
            new import_obsidian5.Notice(`${tags.length} tags added to current note`);
          } else {
            console.error("Tags added but verification failed");
            this.statusBarItem.setText("");
            new import_obsidian5.Notice("Tags seem not to be successfully added, please check editor content");
          }
        } catch (writeError) {
          console.error("Error adding tags to editor:", writeError);
          this.statusBarItem.setText("");
          new import_obsidian5.Notice("Failed to add tags: " + (writeError.message || "Editor error"));
        }
      } else {
        this.statusBarItem.setText("");
        new import_obsidian5.Notice("Unable to generate tags, please check API settings and note content");
      }
    } catch (error) {
      console.error("Error tagging current note:", error);
      this.statusBarItem.setText("");
      new import_obsidian5.Notice("Error tagging current note: " + (error.message || "Unknown error"));
    }
  }
  async processBatchWithLimit(files, batchSize = 3) {
    let tagged = 0;
    let errors = 0;
    const totalFiles = files.length;
    for (let i = 0; i < totalFiles; i += batchSize) {
      const batch = files.slice(i, i + batchSize);
      const startMsg = `Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(totalFiles / batchSize)}, ${batch.length} files`;
      console.log(startMsg);
      this.statusBarItem.setText(`${startMsg} (Completed: ${tagged})`);
      const results = await Promise.all(batch.map(async (file) => {
        try {
          console.log(`Reading file: ${file.path}`);
          const content = await this.app.vault.read(file);
          console.log(`Generating tags for file: ${file.path}`);
          const tags = await this.generateTags(content);
          if (tags && tags.length > 0) {
            const cleanedContent = content.replace(/^(#[^\s#]+\s*)+\n+/, "");
            const tagsText = tags.join(" ");
            const newContent = tagsText + "\n\n" + cleanedContent;
            console.log(`Preparing to write file: ${file.path}, tags: ${tagsText}`);
            try {
              await this.app.vault.modify(file, newContent);
              console.log(`Successfully wrote file: ${file.path}`);
              const verifyContent = await this.app.vault.read(file);
              if (verifyContent.startsWith(tagsText)) {
                console.log(`Verification successful: File ${file.path} contains tags`);
                return { success: true, file: file.path };
              } else {
                console.error(`Verification failed: File ${file.path} does not contain tags`);
                return { success: false, file: file.path, error: "Tag write verification failed" };
              }
            } catch (writeError) {
              console.error(`Failed to write file: ${file.path}`, writeError);
              return { success: false, file: file.path, error: writeError.message || "Write failed" };
            }
          } else {
            console.log(`Unable to generate tags for file: ${file.path}`);
            return { success: false, file: file.path, error: "Unable to generate tags" };
          }
        } catch (error) {
          console.error(`Error processing file: ${file.path}`, error);
          return { success: false, file: file.path, error: error.message || "Unknown error" };
        }
      }));
      for (const result of results) {
        if (result.success) {
          tagged++;
        } else {
          errors++;
          console.error(`Processing failed: ${result.file}, reason: ${result.error}`);
        }
      }
      if (i + batchSize < totalFiles) {
        const pauseMsg = `Completed ${i + batch.length}/${totalFiles}, pausing 1 second before continuing...`;
        console.log(pauseMsg);
        this.statusBarItem.setText(pauseMsg);
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
    }
    return { tagged, errors };
  }
  async tagAllNotes() {
    try {
      const files = this.app.vault.getMarkdownFiles();
      if (!files || files.length === 0) {
        new import_obsidian5.Notice("No Markdown notes found");
        return;
      }
      new import_obsidian5.Notice(`Starting to tag ${files.length} notes, this may take some time...`);
      console.log(`Preparing to process ${files.length} files`);
      const startTime = Date.now();
      const batchSize = 3;
      const { tagged, errors } = await this.processBatchWithLimit(files, batchSize);
      const timeTaken = ((Date.now() - startTime) / 1e3).toFixed(1);
      this.statusBarItem.setText("");
      new import_obsidian5.Notice(`Tag generation completed! Successfully tagged: ${tagged} notes, failed: ${errors} notes, time taken: ${timeTaken} seconds`);
      console.log(`Processing completed, successfully: ${tagged}, failed: ${errors}, time taken: ${timeTaken} seconds`);
    } catch (error) {
      console.error("Error processing all notes:", error);
      this.statusBarItem.setText("");
      new import_obsidian5.Notice("Error processing all notes: " + (error.message || "Unknown error"));
    }
  }
  async clearCurrentNoteTags(editor, view) {
    try {
      if (!view.file) {
        new import_obsidian5.Notice("No note opened");
        return;
      }
      const content = editor.getValue();
      console.log("Clearing tags: Getting current content, length:", content.length);
      const tagPattern = /^(#[^\s#]+\s*)+\n+/;
      const match = content.match(tagPattern);
      if (match) {
        console.log("Found tag line:", match[0]);
        const cleanedContent = content.replace(tagPattern, "");
        console.log(`Cleared tags content length: ${cleanedContent.length}`);
        editor.setValue(cleanedContent);
        await new Promise((resolve) => setTimeout(resolve, 100));
        const newContent = editor.getValue();
        if (!newContent.match(tagPattern)) {
          console.log("Tags cleared successfully, verification passed");
          new import_obsidian5.Notice("Current note tags cleared");
        } else {
          console.error("Tags cleared but verification failed");
          new import_obsidian5.Notice("Tags seem not to be successfully cleared");
        }
      } else {
        console.log("Current note does not detect tags");
        new import_obsidian5.Notice("Current note does not detect tags");
      }
    } catch (error) {
      console.error("Error clearing tags:", error);
      new import_obsidian5.Notice("Error clearing tags: " + (error.message || "Unknown error"));
    }
  }
  async clearAllNotesTags() {
    const files = this.app.vault.getMarkdownFiles();
    let cleared = 0;
    new import_obsidian5.Notice(`Starting to clear ${files.length} notes' tags...`);
    for (const file of files) {
      try {
        const content = await this.app.vault.read(file);
        const cleanedContent = content.replace(/^(#[^\s#]+\s*)+\n+/, "");
        if (content !== cleanedContent) {
          await this.app.vault.modify(file, cleanedContent);
          cleared++;
        }
      } catch (error) {
        console.error(`Error clearing note ${file.path} tags:`, error);
      }
    }
    new import_obsidian5.Notice(`Tag clearing completed! Cleared ${cleared} notes' tags`);
  }
};
var TagCountAdjustModal = class extends import_obsidian5.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.newTagCount = plugin.settings.tagCount;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Adjust Tag Count" });
    const settingDiv = contentEl.createDiv();
    settingDiv.createEl("p", { text: `Current tag count: ${this.plugin.settings.tagCount}` });
    const sliderContainer = settingDiv.createDiv();
    const slider = sliderContainer.createEl("input");
    slider.type = "range";
    slider.min = "1";
    slider.max = "20";
    slider.value = this.plugin.settings.tagCount.toString();
    slider.addClass("tag-count-slider");
    const valueDisplay = settingDiv.createEl("p", { text: `New tag count: ${this.plugin.settings.tagCount}` });
    slider.addEventListener("input", () => {
      this.newTagCount = parseInt(slider.value);
      valueDisplay.textContent = `New tag count: ${this.newTagCount}`;
    });
    const buttonDiv = contentEl.createDiv();
    buttonDiv.addClass("modal-button-container");
    const saveButton = buttonDiv.createEl("button", { text: "Save" });
    saveButton.addEventListener("click", async () => {
      this.plugin.settings.tagCount = this.newTagCount;
      await this.plugin.saveSettings();
      new import_obsidian5.Notice(`Tag count updated to ${this.newTagCount}`);
      this.close();
    });
    const cancelButton = buttonDiv.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
